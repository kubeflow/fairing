from __future__ import unicode_literals
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
from builtins import filter
from builtins import int
from future import standard_library
standard_library.install_aliases()

import logging
import random
import math
import json

logger = logging.getLogger('fairing')


class ExploitStrategy(object):
    pass

# TODO: parametrize truncation limits


class Truncation(ExploitStrategy):
    def exploit(self, current_instance_id, scoreboard):
        # Check if current_istance_id is in the worst 20%, if yes returns the path
        # and hp of a model that is in the top 20%
        # otherwise returns None
        population_size = len(scoreboard)
        curr_item = list(
            filter(lambda x: x['id'] == current_instance_id, scoreboard))[0]
        rank = scoreboard.index(curr_item)

        if not rank >= math.floor(population_size * 0.8):
            return None, None

        # randomly choose a member to copy from the top 20%
        high_bound = max(int(population_size * 0.2) - 1, 0)
        top_id = random.randint(0, high_bound)
        model_path = scoreboard[top_id]['model_path']
        hp = json.loads(scoreboard[top_id]['hp'])
        return model_path, hp


class BinaryTournament(ExploitStrategy):
    pass
